{"version":3,"sources":["simulation.js","TopMenu.js","useMutableState.js","SidePanel.js","Particle.js","Arrow.js","FieldArrows.js","SelectionArrows.js","App.js","index.js"],"names":["Particle","key","position","rotation","scale","onClick","scene","mass","charge","AddParticle","relativePosition","Vector3","subVectors","this","length","fieldStrength","clone","multiplyScalar","divideScalar","value","selected","Scene","particles","particle","push","index","findIndex","item","splice","totalFieldStrength","i","add","CalculateGravField","CalculateElecField","TopMenu","props","useState","fieldArrowMode","setFieldArrowMode","AppBar","Toolbar","Typography","variant","style","margin","padding","background","color","onChange","event","target","MenuItem","useMutableState","init","state","_setState","stateRef","useRef","data","current","useStyles","makeStyles","title","removeBtn","backgroundColor","isFloat","match","SidePanel","forceUpdateDummy","setForceUpdateDummy","forceUpdate","classes","selection","GetInspectorInfo","tempVectors","tempScalars","handleKeyPress","code","id","split","vector","vectors","tempVector","set","parseFloat","y","z","Math","round","x","forceCanvasUpdate","map","scalars","get","useEffect","Object","entries","pair","toArray","flat","vectorInputs","property","TableRow","TableCell","colSpan","align","TextField","width","onKeyPress","size","scalarInputs","Drawer","anchor","Box","className","Table","TableBody","Button","RemoveParticle","deselect","mesh","copy","ref","args","Arrow","useGLTF","nodes","materials","geometry","Cylinder","n","dispose","meshMaterial","FieldArrows","arrows","pos","sideLength","field","fieldMagnitude","CalculateTotalGravField","max","min","CalculateTotalElecField","normalize","rotationQ","Quaternion","setFromUnitVectors","Euler","setFromQuaternion","cameraZoom","SelectionArrows","materialZ","materialX","materialY","movingArrow","PI","selectArrow","hidden","mode2D","OrbitControls","useFrame","camera","cameraPos","lookAt","focus","preload","App","setPos","mouse","setMouse","orbit","setMovingArrow","originalPos","particleNumber","setParticleNumber","setSelected","canvas","Sim","addParticle","object","handleMouseUp","shiftKey","addEventListener","handleMouseMove","speed","newRel","deltaY","handleScroll","up","side","newPos","crossVectors","applyAxisAngle","movementX","movementY","_setFieldArrowMode","mode","axis","display","flexDirection","height","flex","intensity","Fab","bottom","left","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.271c8d1a.chunk.js","sourcesContent":["import { Vector3 } from \"three\";\r\n\r\n// The values calculated by the particle methods are actually accurate\r\n// if the mass and charge of the particles were measured in kilograms and coulombs.\r\nconst GRAVITATIONAL_CONSTANT = 0.00000000006674;\r\nconst COULOMB_CONSTANT = 8988000000;\r\n\r\nclass SimulationObject {\r\n  constructor(key, position, rotation, scale, onClick, scene) {\r\n    this.key = key;\r\n    this.position = position;\r\n    this.rotation = rotation;\r\n    this.scale = scale;\r\n    this.onClick = onClick;\r\n    this.scene = scene;\r\n    this.selected = false;\r\n  }\r\n}\r\n\r\n\r\nclass Particle extends SimulationObject {\r\n  constructor(key, position, rotation, scale, onClick, scene, mass, charge) {\r\n    super(key, position, rotation, scale, onClick, scene);\r\n    this.mass = mass;\r\n    this.charge = charge;\r\n    // Particles add themselves to the scene that's passed to them as an argument.\r\n    scene.AddParticle(this);\r\n  }\r\n\r\n  CalculateGravField(position) {\r\n    // relativePosition is the vector from this particle to the vector position.\r\n    let relativePosition = new Vector3();\r\n    relativePosition.subVectors(position, this.position);\r\n    // if position is actually on top of particle, to avoid a division by\r\n    // zero error, a zero vector is returned.\r\n    if (relativePosition.length() === 0) {\r\n      return new Vector3();\r\n    }\r\n    let fieldStrength = relativePosition.clone();\r\n    // The field is proportional to the particle's mass.\r\n    fieldStrength.multiplyScalar(-GRAVITATIONAL_CONSTANT * this.mass);\r\n    // The field faces from position to the particle, and its magnitude\r\n    // is proportional to the inverse square of the distance between them.\r\n    // Therefore the relative position vector would have to be first normalised\r\n    // by dividing it by that distance, and then divided by the square of\r\n    // the distance again. I combine these two steps here by dividing it by the\r\n    // cube of relativePosition's length.\r\n    fieldStrength.divideScalar(relativePosition.length() ** 3);\r\n    return fieldStrength;\r\n  }\r\n\r\n  CalculateElecField(position) {\r\n    // relativePosition is the vector from this particle to the vector position.\r\n    let relativePosition = new Vector3();\r\n    relativePosition.subVectors(position, this.position);\r\n    // if position is actually on top of particle, to avoid a division by\r\n    // zero error, a zero vector is returned.\r\n    if (relativePosition.length() === 0) {\r\n      return new Vector3();\r\n    }\r\n    let fieldStrength = relativePosition.clone();\r\n    // The field is proportional to the particle's charge.\r\n    fieldStrength.multiplyScalar(COULOMB_CONSTANT * this.charge);\r\n    // The field's magnitude is proportional to the inverse square of the\r\n    // distance between the particle and the position it is measured from.\r\n    // Therefore the relative position vector would have to be first normalised\r\n    // by dividing it by that distance, and then divided by the square of\r\n    // the distance again. I combine these two steps here by dividing it by the\r\n    // cube of relativePosition's length.\r\n    fieldStrength.divideScalar(relativePosition.length() ** 3);\r\n    return fieldStrength;\r\n  }\r\n\r\n  GetInspectorInfo() {\r\n    // This function returns the information to be displayed in the Inspector window.\r\n    let data = {\r\n      \"vectors\":{\r\n        \"Position\":this.position\r\n      },\r\n      \"scalars\":{\r\n        \"Mass\": {\"get\":() => this.mass, \"set\":value => this.mass = value},\r\n        \"Charge\": {\"get\":() => this.charge, \"set\":value => this.charge = value},\r\n      }\r\n    }\r\n    return data\r\n  }\r\n}\r\n\r\n\r\nclass Scene {\r\n  // Manages every particle in the scene.\r\n  constructor(particles, sensors=null, settings=null) {\r\n    this.particles = particles;\r\n  }\r\n\r\n  AddParticle(particle) {\r\n    // Adds particles to the list of particles.\r\n    this.particles.push(particle);\r\n  }\r\n\r\n  RemoveParticle(key) {\r\n    // Searches for particles by their key and\r\n    // removes them from the list of particles.\r\n    let index = this.particles.findIndex(item => item.key === key);\r\n    this.particles.splice(index, index+1);\r\n  }\r\n\r\n  CalculateTotalGravField(position) {\r\n    // This function simply adds together the gravitational\r\n    // fields from all the particles in the scene.\r\n    let totalFieldStrength = new Vector3();\r\n    for (var i of this.particles) {\r\n      totalFieldStrength.add(i.CalculateGravField(position));\r\n    }\r\n    return totalFieldStrength;\r\n  }\r\n\r\n  CalculateTotalElecField(position) {\r\n    // This function simply adds together the electric\r\n    // fields from all the particles in the scene.\r\n    let totalFieldStrength = new Vector3();\r\n    for (var i of this.particles) {\r\n      totalFieldStrength.add(i.CalculateElecField(position));\r\n    }\r\n    return totalFieldStrength;\r\n  }\r\n}\r\n\r\n\r\nexport {Particle, Scene};\r\n","import { useState } from 'react';\r\nimport { AppBar, Toolbar, Typography, Select, MenuItem} from \"@material-ui/core\";\r\nimport \"typeface-roboto\";\r\n\r\nexport default function TopMenu(props) {\r\n  const [fieldArrowMode, setFieldArrowMode] = useState(\"N\");\r\n  return (\r\n    <AppBar position=\"absolute\">\r\n      <Toolbar>\r\n        <Typography variant=\"h5\" style={{margin:\"10px\"}}>\r\n          Simulation\r\n        </Typography>\r\n        {/* This is the dropdown that allows the user to\r\n          change which field the field arrows follow.\r\n          The reason why two setFieldArrowMode functions are called\r\n          when it changes is because one changes the state in this component,\r\n          and the other is a callback function to change the state in the App\r\n          component. */}\r\n        <Select style={{\r\n              padding:\"6px\",\r\n              background:\"royalblue\",\r\n              color:\"white\"}}\r\n            value={fieldArrowMode}\r\n            onChange={event => {\r\n              setFieldArrowMode(event.target.value);\r\n              props.setFieldArrowMode(event.target.value)\r\n            }}>\r\n          <MenuItem value={\"G\"}>Gravitational Field</MenuItem>\r\n          <MenuItem value={\"E\"}>Electric Field</MenuItem>\r\n          <MenuItem value={\"N\"}>No Field Arrows</MenuItem>\r\n        </Select>\r\n      </Toolbar>\r\n    </AppBar>\r\n  )\r\n}\r\n","import React, { useState, useRef } from 'react';\r\n\r\n// This is a custom hook that I had to use to get around the fact\r\n// that React doesn't allow callback functions to directly change state.\r\n// Instead it puts the value in a mutable ref.\r\nexport default function useMutableState(init) {\r\n  const [state, _setState] = useState(init);\r\n  const stateRef = useRef(state);\r\n  const setState = data => {\r\n    stateRef.current = data;\r\n    _setState(data);\r\n  }\r\n  return [stateRef, setState];\r\n}\r\n","import React, { useState, useEffect, useRef } from 'react';\r\nimport {\r\n  Drawer,\r\n  Box,\r\n  Table,\r\n  TableBody,\r\n  TableRow,\r\n  TableCell,\r\n  TextField,\r\n  Typography,\r\n  Button } from '@material-ui/core';\r\nimport \"typeface-roboto\";\r\nimport { makeStyles } from \"@material-ui/core/styles\"\r\nimport useMutableState from \"./useMutableState\";\r\n\r\n// This is an example of a higher order function: makeStyles returns a custom hook\r\n// that allows me to use the css classes defined here in my React components.\r\nconst useStyles = makeStyles({\r\n  title: {\r\n    background:\"dodgerblue\",\r\n    color:\"white\",\r\n    padding:\"10px\"\r\n  },\r\n  removeBtn: {\r\n    background:\"red\",\r\n    color: \"white\",\r\n    '&:hover': {\r\n      backgroundColor: 'darkred',\r\n    }\r\n  }\r\n});\r\n\r\n// JavaScript's parseFloat didn't serve my purposes to check if a string\r\n// could be parsed as a float or not, so I wrote this quick function\r\n// using RegEx to do so.\r\nfunction isFloat(value) {\r\n  return value.match(/^-?[0-9]*\\.?[0-9]*$/) !== null\r\n}\r\n\r\nexport default function SidePanel(props) {\r\n  // This is the same function as in App: it forces an update by\r\n  // changing the dummy variable.\r\n  const [forceUpdateDummy, setForceUpdateDummy] = useMutableState(false);\r\n  function forceUpdate() {\r\n    setForceUpdateDummy(!forceUpdateDummy.current);\r\n  }\r\n\r\n  // Calling that custom hook from earlier.\r\n  const classes = useStyles();\r\n\r\n  // Here the GetInspectorInfo method of the selected object is called.\r\n  // It returns an object with getters and setters of the values which\r\n  // the object would like to display.\r\n  // The format of this info is as follows:\r\n  // data is an object with two attributes, vectors and scalars.\r\n  // - vectors is an object where its attribute names are the names\r\n  //   that should be displayed, and the value of said attributes\r\n  //   are reference to the corresponding vectors.\r\n  // - scalars is an object where its attribute names are the names\r\n  //   that should be displayed, and the value of said attributes\r\n  //   are objects with a get and set attribute which correspond\r\n  //   to the getter and setter functions of the attribute.\r\n  const data = useRef(props.selection.GetInspectorInfo());\r\n  // These objects contain the temporary values that are displayed\r\n  // in the Inspector window. These values are applied when the user enters them.\r\n  const tempVectors = useRef({});\r\n  const tempScalars = useRef({});\r\n\r\n  // This side effect runs every time the selected object is changed.\r\n  // It gets the new data, and initializes tempScalars to the current values that\r\n  // the scalars in data, using the getters.\r\n  useEffect(() => {\r\n    data.current = props.selection.GetInspectorInfo();\r\n    tempScalars.current = {};\r\n    for (var [key, value] of Object.entries(data.current.scalars)) {\r\n      tempScalars.current[key] = value.get();\r\n    }\r\n    forceUpdate();\r\n  }, [props.selection]);\r\n\r\n  // This side effect runs both when the selected object changes and when the\r\n  // vectors in data change.\r\n  // It updates tempVectors to reflect the change.\r\n  // The expression in the dependency array (second argument) of useEffect represents an Array\r\n  // of every x y and z value in all the vectors in data.\r\n  useEffect (() => {\r\n      for (var vector in data.current.vectors) {\r\n      tempVectors.current[vector] = [\r\n        data.current.vectors[vector].x,\r\n        data.current.vectors[vector].y,\r\n        data.current.vectors[vector].z\r\n      ].map(item => Math.round(item*100)/100);\r\n    }\r\n  }, [props.selection, ...Object.entries(data.current.vectors).map(pair => {return pair[1].toArray()}).flat()]);\r\n\r\n  // This function is the callback function for keypresses on the textfields of the\r\n  // inspecter window. If the key pressed was an enter key, the id attribute of the textfield\r\n  // is parsed to see if it was a vector or scalar (\"v\" or \"s\"), what property it corresponded to,\r\n  // and if it was a vector, what component of the vector it was (\"x\", \"y\", or \"z\").\r\n  // Then, the value in the textfield is validated, and if it is valid, the corresponding\r\n  // value in data is updated, and if not, the value in the textfield is overwritten\r\n  // by the current value in data.\r\n  function handleKeyPress(event) {\r\n    if (event.code === \"Enter\") {\r\n      let id = event.target.id.split(\" \");\r\n      // Switch to check if the textfield changed a vector or scalar.\r\n      switch (id[0]) {\r\n        case \"v\":\r\n          // Validate value:\r\n          if (isFloat((event.target.value))) {\r\n            // Temporary variables to shorten code.\r\n            // vector is the corresponding vector in data,\r\n            // and tempVector is the corresponding vector in tempVectors.\r\n            let vector = data.current.vectors[id[1]];\r\n            let tempVector = tempVectors.current[id[1]];\r\n\r\n            //This switch checks what component of the vector changed,\r\n            // and updates the corresponding component of vector.\r\n            switch (id[2]) {\r\n              case \"x\":\r\n                vector.set(parseFloat(event.target.value), vector.y, vector.z);\r\n                tempVector[0] = Math.round(parseFloat(event.target.value)*100)/100;\r\n                break;\r\n              case \"y\":\r\n                vector.set(vector.x, parseFloat(event.target.value), vector.z);\r\n                tempVector[1] = Math.round(parseFloat(event.target.value)*100)/100;\r\n                break;\r\n              case \"z\":\r\n                vector.set(vector.x, vector.y, parseFloat(event.target.value));\r\n                tempVector[2] = Math.round(parseFloat(event.target.value)*100)/100;\r\n            }\r\n            props.forceCanvasUpdate();\r\n          } else {\r\n            // If the validation check fails, tempVectors is updated to reflect\r\n            // to reflect the actual value of the vector in data.\r\n            tempVectors.current[id[1]] = [\r\n              data.current.vectors[id[1]].x,\r\n              data.current.vectors[id[1]].y,\r\n              data.current.vectors[id[1]].z\r\n            ].map(item => Math.round(item*100)/100);\r\n            forceUpdate();\r\n          }\r\n          break;\r\n        case \"s\":\r\n          // When the textfield is from a scalar value, the validation check\r\n          // doesn't allow the field with the name \"Mass\" to take a negative value.\r\n          if (isFloat((event.target.value)) && !(parseFloat(event.target.value) < 0 && id[1] === \"Mass\")) {\r\n            data.current.scalars[id[1]].set(parseFloat(event.target.value));\r\n            props.forceCanvasUpdate();\r\n          } else {\r\n            //Again, if the validation check fails, tempScalars is updated.\r\n            tempScalars.current[id[1]] = data.current.scalars[id[1]].get();\r\n            forceUpdate();\r\n          }\r\n      }\r\n    }\r\n  }\r\n\r\n  // This Array will contain the actual TextField components for the vectors.\r\n  let vectorInputs = [];\r\n\r\n  for (const property in tempVectors.current) {\r\n    // This will add a row for the name of the current vector.\r\n    vectorInputs.push(\r\n      <TableRow>\r\n        <TableCell colSpan=\"3\">\r\n          <Typography variant=\"body1\" align=\"center\"><b>{property}</b></Typography>\r\n        </TableCell>\r\n      </TableRow>\r\n    );\r\n\r\n    // This adds the textfields themselves.\r\n    vectorInputs.push(\r\n      <TableRow>\r\n        <TableCell>\r\n          <TextField\r\n            id={`v ${property} x`}\r\n            style={{width:\"70px\"}}\r\n            onKeyPress={handleKeyPress}\r\n            onChange={event => {tempVectors.current[property][0] = event.target.value; forceUpdate()}}\r\n            variant=\"outlined\"\r\n            size=\"small\"\r\n            value={tempVectors.current[property][0]}/>\r\n        </TableCell>\r\n        <TableCell>\r\n          <TextField\r\n            id={`v ${property} y`}\r\n            style={{width:\"70px\"}}\r\n            onKeyPress={handleKeyPress}\r\n            onChange={event => {tempVectors.current[property][1] = event.target.value; forceUpdate()}}\r\n            variant=\"outlined\"\r\n            size=\"small\"\r\n            value={tempVectors.current[property][1]}/>\r\n        </TableCell>\r\n        <TableCell>\r\n          <TextField\r\n            id={`v ${property} z`}\r\n            style={{width:\"70px\"}}\r\n            onKeyPress={handleKeyPress}\r\n            onChange={event => {tempVectors.current[property][2] = event.target.value; forceUpdate()}}\r\n            variant=\"outlined\"\r\n            size=\"small\"\r\n            value={tempVectors.current[property][2]}/>\r\n        </TableCell>\r\n      </TableRow>\r\n    );\r\n  }\r\n\r\n  // Similarly here, this Array will contain all the TextField components for the scalars.\r\n  let scalarInputs = [];\r\n\r\n  for (const property in tempScalars.current) {\r\n    scalarInputs.push(\r\n      <TableRow>\r\n        <TableCell>\r\n          <Typography variant=\"body1\"><b>{property}</b></Typography>\r\n        </TableCell>\r\n        <TableCell>\r\n          <TextField\r\n          id={`s ${property}`}\r\n          style={{width:\"70px\"}}\r\n          onKeyPress={handleKeyPress}\r\n          onChange={event => {tempScalars.current[property] = event.target.value; forceUpdate()}}\r\n          variant=\"outlined\"\r\n          size=\"small\"\r\n          value={tempScalars.current[property]}/>\r\n        </TableCell>\r\n      </TableRow>\r\n    );\r\n  }\r\n\r\n  // This is a small callback function to remove the selected\r\n  // particle and deselect it.\r\n  function Remove() {\r\n    props.selection.scene.RemoveParticle(props.selection.key);\r\n    props.deselect();\r\n  }\r\n\r\n  return (\r\n    <Drawer anchor=\"right\" variant=\"permanent\">\r\n      <Box className={classes.title}>\r\n        <Typography align=\"center\" variant=\"h6\">Inspector window</Typography>\r\n      </Box>\r\n      <Table>\r\n        <TableBody>\r\n          {vectorInputs}\r\n          {scalarInputs}\r\n        </TableBody>\r\n      </Table>\r\n      <Button className={classes.removeBtn}\r\n        onClick={Remove}>\r\n          Remove\r\n        </Button>\r\n    </Drawer>\r\n  )\r\n}\r\n","import { useRef, useEffect } from \"react\";\r\nimport { Mesh, MeshStandardMaterial, SphereBufferGeometry } from \"three\";\r\n\r\nexport default function Particle(props) {\r\n  const mesh = useRef();\r\n\r\n  // This side effect updates the position of the model when the position\r\n  // argument changes.\r\n  useEffect(() => {mesh.current.position.copy(props.position)},\r\n    [props.position.x, props.position.y, props.position.z]);\r\n\r\n  return (\r\n    <mesh\r\n    position={props.position ? props.position : [0,0,0]}\r\n    scale={props.scale ? props.scale : [1,1,1]}\r\n    onClick={props.onClick}\r\n    ref={mesh}>\r\n      <sphereBufferGeometry args={[0.5]} />\r\n      <meshStandardMaterial color={props.selected ? \"gray\" : \"green\"} />\r\n    </mesh>\r\n  )\r\n}\r\n","/*\r\nAuto-generated by: https://github.com/pmndrs/gltfjsx\r\n*/\r\n\r\n// This code was autogenerated and then customized to suit my needs.\r\n// It loads the model for the arrow, which is not a default model in Three.js.\r\n\r\nimport React, { useEffect, useRef } from 'react'\r\nimport { useGLTF } from '@react-three/drei'\r\nimport { MeshStandardMaterial } from 'three'\r\n\r\nexport default function Arrow(props) {\r\n  // This loads the arrow model.\r\n  const { nodes, materials } = useGLTF('/arrow_model.glb')\r\n  const mesh = useRef();\r\n  // This side effect updates the position of the model when the position\r\n  // argument changes.\r\n  useEffect(() => {\r\n    mesh.current.position.copy(props.position);\r\n  }, [props.position.x, props.position.y, props.position.z]);\r\n\r\n  const args = {\r\n    geometry:nodes.Cylinder.geometry,\r\n    position: props.position ? props.position : [0,0,0],\r\n    rotation: props.rotation ? props.rotation : [0,0,0],\r\n    scale: typeof props.scale !== \"undefined\" ? [0.187, 1.4, 0.187].map(n => n*props.scale) : [0.187, 1.4, 0.187],\r\n    onClick: props.onClick\r\n  };\r\n  return (\r\n    <group dispose={null}>\r\n      <mesh {...args} ref={mesh}>\r\n        <meshStandardMaterial color = {props.color ? props.color : 'purple'} ref={props.meshMaterial}/>\r\n      </mesh>\r\n    </group>\r\n  )\r\n}\r\n\r\nuseGLTF.preload('/arrow_model.glb')\r\n","import { Vector3, Quaternion, Euler } from \"three\";\r\nimport Arrow from \"./Arrow\";\r\n\r\nexport default function FieldArrows(props) {\r\n  // sideLength represents how many arrows there should be on each edge of the 3D grid.\r\n  // With 6 on each edge, that makes 216.\r\n  const sideLength = 6;\r\n  // These two variables represent the maximum and minimum size thqt the field arrows\r\n  // can reach.\r\n  const [max, min] = [0.4, 0];\r\n  // This Array will hold all the Arrow components.\r\n  const arrows = [];\r\n  for (var x = 0; x < sideLength; x++) {\r\n    for (var y = 0; y < sideLength; y++) {\r\n      for (var z = 0; z < sideLength; z++) {\r\n        let pos = new Vector3(x-sideLength/2+0.5, y-sideLength/2+0.5, z-sideLength/2+0.5);\r\n        pos.multiplyScalar(3);\r\n        let field = new Vector3();\r\n        let fieldMagnitude = 0;\r\n        // This switch sets field and fieldMagnitude to the field strength and\r\n        // magnitude for either the gravitational field or the electric field.\r\n        switch (props.fieldArrowMode) {\r\n          case \"G\":\r\n            field = props.scene.CalculateTotalGravField(pos);\r\n            fieldMagnitude = Math.max(Math.min(field.length()*100000000000, max), min);\r\n            break;\r\n          case \"E\":\r\n            field = props.scene.CalculateTotalElecField(pos);\r\n            fieldMagnitude = Math.max(Math.min(field.length()/1000000000, max), min);\r\n            break;\r\n        }\r\n        // This section calculates what rotation the arrow should have.\r\n        field.normalize();\r\n        let rotationQ = new Quaternion();\r\n        rotationQ.setFromUnitVectors(new Vector3(0,-1,0), field);\r\n        let rotation = new Euler();\r\n        rotation.setFromQuaternion(rotationQ);\r\n        arrows.push(<Arrow\r\n          key={`${x} ${y} ${z}`}\r\n          position={pos}\r\n          scale={props.cameraZoom*fieldMagnitude}\r\n          rotation={rotation}\r\n          color=\"darkblue\"/>);\r\n      }\r\n    }\r\n  }\r\n  return arrows\r\n}\r\n","import Arrow from \"./Arrow\";\r\nimport { Euler } from \"three\";\r\nimport { useEffect, useRef } from \"react\";\r\n\r\nexport default function SelectionArrows(props) {\r\n  const materialZ = useRef(null);\r\n  const materialX = useRef(null);\r\n  const materialY = useRef(null);\r\n\r\n  // This side effect changes the colour of the selected arrow to yellow\r\n  // when a new arrow is selected.\r\n  useEffect(() => {\r\n    switch (props.movingArrow) {\r\n      case 'X':\r\n        materialX.current.color.set('yellow');\r\n        materialY.current.color.set('green');\r\n        materialZ.current.color.set('blue');\r\n        break;\r\n      case 'Y':\r\n        materialX.current.color.set('red');\r\n        materialY.current.color.set('yellow');\r\n        materialZ.current.color.set('blue');\r\n        break;\r\n      case 'Z':\r\n        materialX.current.color.set('red');\r\n        materialY.current.color.set('green');\r\n        materialZ.current.color.set('yellow');\r\n        break;\r\n      default:\r\n        materialX.current.color.set('red');\r\n        materialY.current.color.set('green');\r\n        materialZ.current.color.set('blue');\r\n    }\r\n  }, [props.movingArrow]);\r\n\r\n  return (\r\n    <group>\r\n      <Arrow\r\n      color={props.movingArrow === 'X' ? 'yellow' : 'red'}\r\n      scale={props.scale ? props.scale : 0.5}\r\n      rotation={new Euler(0,0,Math.PI/2)}\r\n      position={props.position}\r\n      onClick={() => props.selectArrow('X')}\r\n      meshMaterial={materialX}/>\r\n      <Arrow\r\n      hidden={props.mode2D}\r\n      color= {props.movingArrow === 'Y' ? 'yellow' : 'green'}\r\n      scale={props.scale ? props.scale : 0.5}\r\n      rotation={new Euler(0,0,Math.PI)}\r\n      position={props.position}\r\n      onClick={() => props.selectArrow('Y')}\r\n      meshMaterial={materialY}/>\r\n      <Arrow\r\n      color={props.movingArrow === 'Z' ? 'yellow' : 'blue'}\r\n      scale={props.scale ? props.scale : 0.5}\r\n      rotation={new Euler(-Math.PI/2,0,0)}\r\n      position={props.position}\r\n      onClick={() => props.selectArrow('Z')}\r\n      meshMaterial={materialZ}/>\r\n    </group>\r\n  )\r\n}\r\n","import { useState, useRef, useEffect } from \"react\";\nimport { Canvas, useFrame } from \"@react-three/fiber\";\nimport { Vector3, Quaternion } from \"three\";\nimport { Fab } from \"@material-ui/core\";\nimport AddIcon from \"@material-ui/icons/Add\";\n\n// Here I import the classes and components from other files\nimport * as Sim from \"./simulation.js\";\nimport TopMenu from \"./TopMenu\";\nimport SidePanel from \"./SidePanel.js\";\nimport Particle from \"./Particle\";\nimport FieldArrows from \"./FieldArrows\";\nimport SelectionArrows from \"./SelectionArrows\";\nimport useMutableState from \"./useMutableState\";\n\n// This component is the only one that doesn't actually return anything:\n// instead it only uses the useFrame hook to run a callback function every\n// frame of the render.\n// Here it moves the camera to the position it recieves as an argument and has\n// it look at the focus (the center of the simulation).\nfunction OrbitControls(props) {\n  useFrame(({ camera }) => {\n    camera.position.set(...props.cameraPos);\n    camera.lookAt(...props.focus);\n  })\n  return null\n}\n\n// This is the main function, the one rendered in the index.js file.\nfunction App() {\n\n  const [cameraPos, setPos] = useMutableState([0,0,5]);\n  const [focus, setFocus] = useState([0,0,0]);\n  const [mouse, setMouse] = useMutableState(false);\n  const [orbit, setOrbit] = useMutableState(true); // Whether to allow camera movement or not\n  const [movingArrow, setMovingArrow] = useMutableState(null);\n  const [originalPos, setOriginalPos] = useMutableState(new Vector3());\n  const [particleNumber, setParticleNumber] = useMutableState(0);\n  const [fieldArrowMode, setFieldArrowMode] = useState(\"N\");\n  const [selected, setSelected] = useMutableState(null);\n  const canvas = useRef();\n  const [scene, setScene] = useMutableState(new Sim.Scene([]));\n\n  // React re-renders components when their arguments or state change, but if they're\n  // just references instead of values, it can't keep track of them as well.\n  // This function forces an update by changing the the dummy variable.\n  const [forceUpdateDummy, setForceUpdateDummy] = useMutableState(false);\n  function forceUpdate() {\n    setForceUpdateDummy(!forceUpdateDummy.current);\n  }\n\n  // This adds a particle to the center of the simulation, with 0 mass and charge.\n  function addParticle() {\n    let particle = new Sim.Particle(\n      particleNumber.current,\n      new Vector3(...focus),\n      new Quaternion(),\n      new Vector3(1,1,1),\n      null,\n      scene.current,\n      0,\n      0\n    );\n    particle.onClick = () => Select(particle);\n    setParticleNumber(particleNumber.current+1);\n  }\n\n  // These calls use the useEffect hook in a slightly unintended way.\n  // The useEffect hook is typically used to allow function components to have side effects\n  // with callback functions, but here I take advantage of how they can be called\n  // only when a value in their dependency array changes (the second argument).\n  // The dependency arrays are all empty, so the callback functions are called only\n  // once when the component is instanced for the first time and not again.\n  // This is useful so that I can add event listeners to the HTML elements just once.\n  useEffect(() => canvas.current.addEventListener('mousemove', handleMouseMove), []);\n  useEffect(() => canvas.current.addEventListener('mousedown', () => setMouse(true)), []);\n  useEffect(() => canvas.current.addEventListener('mouseup', handleMouseUp), []);\n  useEffect(() => canvas.current.addEventListener('wheel', event => handleScroll(event, 0.9)), []);\n  useEffect(() => canvas.current.addEventListener('mouseleave', () => setMouse(false)), []);\n\n  // This function handles the scroll wheel. It zooms in or out a fraction of\n  // the camera's distance to the center, rather than a fixed amount.\n  // Zooming in when already very zoomed in is very slow, and zooming\n  // out when already zoomed out is very fast. The user should experiance less\n  // issues with sensitivity being too high or low, as it is adaptive.\n  function handleScroll(event, speed) {\n    let rel =\n     [focus[0] - cameraPos.current[0],\n      focus[1] - cameraPos.current[1],\n      focus[2] - cameraPos.current[2]];\n    let newRel = rel.map(x => x*(speed*(event.deltaY/1000)));\n    newRel =\n     [cameraPos.current[0]+newRel[0],\n     cameraPos.current[1]+newRel[1],\n     cameraPos.current[2]+newRel[2]];\n    // This check prevents users from zooming out so far in or out that\n    // scene is no longer in the cameras view frustum.\n    if (newRel[0]**2 + newRel[1]**2 + newRel[2]**2 > 0.05 &&\n        newRel[0]**2 + newRel[1]**2 + newRel[2]**2 < 900) {\n      setPos(newRel);\n    }\n  }\n\n  // This function handles mouse clicks away from the selection arrows, mostly.\n  // The main point of interest is the check to see if the shift key was pressed,\n  // and if so return the selected object to it's original position.\n  function handleMouseUp(event) {\n    setMouse(false);\n    if (movingArrow.current) {\n      if (event.shiftKey) {\n        selected.current.position.copy(originalPos.current);\n      }\n      originalPos.current.set(0,0,0);\n      setMovingArrow(null);\n    }\n  }\n\n  // These vectors are here to help orient the camera.\n  // The up vector is constant and simply defines the up direction to be the y axis\n  // for the purposes of this program.\n  // It could have just as easily been in the z direction.\n  // The side vector is recalculated every time the camera is moved and represents a direction\n  // perpendicular to both up and the direction the camera is looking.\n  // The camera is then rotated around the center of the simulation using these as\n  // its axes of rotation.\n  const up = new Vector3(0,1,0);\n  const side = new Vector3(1,0,0);\n\n  function handleMouseMove(event) {\n    if (mouse.current && orbit.current && !movingArrow.current) {\n      // This block of code deals with the camera movement if the mouse is down and\n      // no selection arrow is selected.\n      // newPos is the vector from the camera to the center of the simulation.\n      let newPos = new Vector3(cameraPos.current[0]-focus[0],\n                               cameraPos.current[1]-focus[1],\n                               cameraPos.current[2]-focus[2]);\n      // side is recalculated here.\n      side.crossVectors(up, newPos);\n      side.normalize();\n      // And here newPos is rotated around the two axes proportional to the mouse's movement.\n      newPos.applyAxisAngle(up, event.movementX / -300);\n      newPos.applyAxisAngle(side, event.movementY / -300);\n      // Then the newPos and focus vectors are added together to find the new position of the camera,\n      // and pos is set to the result.\n      newPos = newPos.toArray();\n      newPos = [newPos[0]+focus[0], newPos[1]+focus[1], newPos[2]+focus[2]];\n      setPos(newPos);\n    } else if (movingArrow.current) {\n      // This block of code deals with the selected object's movement when a selection\n      // arrow is selected.\n      // The if statements inside the switch statement are neccessary because the\n      // selected object's movement can be viewed from the front or behind, and in order\n      // for it to follow the mouse in both cases there needs to be a check.\n\n      // Front:\n      // ^\n      // |\n      // O -->\n      // mouse movement matches arrow direction\n      //\n      // Back:\n      //       ^\n      //      |\n      //  <-- O\n      // mouse movement goes against arrow direction\n\n      switch (movingArrow.current) {\n        case 'X':\n        if (focus[2]>cameraPos.current[2]) {\n          selected.current.position.add(new Vector3(event.movementX / -300, 0, 0));\n        } else {\n          selected.current.position.add(new Vector3(event.movementX / 300, 0, 0));\n        }\n        break;\n        case 'Y':\n          selected.current.position.add(new Vector3(0, event.movementY / -300, 0));\n          break;\n        case 'Z':\n          if (focus[0]>cameraPos.current[0]) {\n            selected.current.position.add(new Vector3(0, 0, event.movementX / 300));\n          } else {\n            selected.current.position.add(new Vector3(0, 0, event.movementX / -300));\n          }\n      }\n      forceUpdate();\n    }\n  }\n\n  // This function is passed as a callback function to the particles to allow them\n  // to select themselves when clicked.\n  // There are a few checks to prevent it from accessing the selected object's\n  // attributes when there is no selected object.\n  function Select(object) {\n    if (!movingArrow.current) {\n      if (selected.current) {\n        selected.current.selected=false;\n      }\n      if (object === selected.current) {\n        setSelected(null);\n      } else {\n        object.selected=true;\n        setSelected(object);\n      }\n    }\n  }\n\n  // A simple function (again a callback) to select a selection arrow.\n  function selectArrow(axis) {\n    if (!movingArrow.current) {\n      originalPos.current.copy(selected.current.position);\n      setMovingArrow(axis);\n    }\n  }\n\n  // This callback function may seem useless but the program doesn't actually work without\n  // this so ¯\\_(ツ)_/¯\n  function _setFieldArrowMode(mode) {\n    setFieldArrowMode(mode);\n  }\n\n  // These variables could have been put directly in the return value but were taken out\n  // to make a little more space. cameraZoom is proportional to the distance from the camera\n  // to the center of the simulation.\n  // arrows is the component SelectedArrows, or null if nothing is selected.\n  const cameraZoom=(new Vector3(...cameraPos.current.map((x, i) => x-focus[i]))).length()*0.1;\n  const arrows = selected.current ? (<SelectionArrows\n    position = {selected.current.position ? selected.current.position : new Vector3()}\n    scale={cameraZoom}\n    movingArrow={movingArrow.current}\n    selectArrow={axis => selectArrow(axis)}/>) : null;\n\n  return (\n    <div style={{display:'flex', flexDirection:'column', height:\"100%\"}}>\n      {/* These divs uses the height attribute and flexbox feature of css to fill the screen space */}\n      <div ref={canvas} style={{flex:1}} id=\"canvas\">\n        <Canvas>\n          <OrbitControls cameraPos = {cameraPos.current} focus={focus}/>\n          <ambientLight intensity={0.5} />\n          <pointLight position={[-10, 10, -10]} />\n          {arrows}\n          {/* Lists of components can be rendered, and here I take advantage of that to render all the particles at once */}\n          {scene.current.particles.map(particle => (<Particle {...particle}/>))}\n          <FieldArrows scene={scene.current} cameraZoom={cameraZoom} fieldArrowMode={fieldArrowMode}/>\n        </Canvas>\n      </div>\n      <TopMenu addParticle={addParticle} setFieldArrowMode={mode => _setFieldArrowMode(mode)}/>\n      {/* \"Fab\" actually stands for \"Floating Action Button\", and is the round plus in the bottom left\n        of the UI. It simply adds a particle to the simulation. */}\n      <Fab onClick={addParticle} style={{background:\"skyblue\",position:\"absolute\", bottom:\"20px\", left:\"20px\"}}>\n        <AddIcon />\n      </Fab>\n      {selected.current ? <SidePanel deselect={() => {setSelected(null)}}\n        selection={selected.current}\n        forceCanvasUpdate={forceUpdate} /> : null}\n    </div>\n  )\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\n\n// Render the App component.\nReactDOM.render(\n    <App />,\n  document.getElementById('root')\n);\n"],"sourceRoot":""}